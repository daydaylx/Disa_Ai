#!/usr/bin/env node

import { readFileSync, writeFileSync, existsSync, statSync } from "fs";
import { join } from "path";

/**
 * Autopilot Summary Generator
 * Parses autopilot.log and generates a structured PR body in Markdown
 */

function parseAutopilotLog() {
  const logPath = "autopilot.log";

  if (!existsSync(logPath)) {
    console.log("No autopilot.log found, creating basic summary");
    return {
      eslintFixes: 0,
      prettierChanges: 0,
      cspFindings: [],
      buildStats: {},
      scriptResults: [],
      errors: [],
    };
  }

  const logContent = readFileSync(logPath, "utf-8");
  const lines = logContent.split("\n");

  const results = {
    eslintFixes: 0,
    prettierChanges: 0,
    cspFindings: [],
    buildStats: {},
    scriptResults: [],
    errors: [],
  };

  let currentSection = null;

  for (const line of lines) {
    // ESLint fixes
    if (line.includes("‚úì") && line.includes("fixed")) {
      const match = line.match(/(\d+)\s+problems?\s+fixed/);
      if (match) {
        results.eslintFixes += parseInt(match[1]);
      }
    }

    // Prettier changes
    if (line.includes("prettier") && line.includes("wrote")) {
      results.prettierChanges++;
    }

    // CSP violations
    if (line.includes("CSP violation") || line.includes("Content Security Policy")) {
      results.cspFindings.push(line.trim());
    }

    // Build stats
    if (line.includes("dist/") && line.includes("kB")) {
      const match = line.match(/(dist\/[^\s]+)\s+([0-9.]+)\s+kB/);
      if (match) {
        results.buildStats[match[1]] = match[2] + " kB";
      }
    }

    // Script results
    if (
      line.includes("setup-verify.mjs") ||
      line.includes("setup-alias.mjs") ||
      line.includes("csp-smoke.mjs")
    ) {
      currentSection = line.trim();
    } else if (
      currentSection &&
      (line.includes("‚úì") || line.includes("‚úó") || line.includes("PASS") || line.includes("FAIL"))
    ) {
      results.scriptResults.push(`${currentSection}: ${line.trim()}`);
      currentSection = null;
    }

    // Errors
    if (line.includes("Error:") || line.includes("ERROR") || line.includes("FAILED")) {
      results.errors.push(line.trim());
    }
  }

  return results;
}

function getBuildSize() {
  const distPath = "dist";
  if (!existsSync(distPath)) {
    return "N/A";
  }

  try {
    const stats = statSync(distPath);
    return `Build folder exists (${stats.isDirectory() ? "directory" : "file"})`;
  } catch {
    return "N/A";
  }
}

function generatePRBody(results) {
  const timestamp = new Date().toISOString();

  let body = `## ü§ñ Autopilot Maintenance Summary

*Automated maintenance run completed at ${timestamp}*

### üìä Changes Applied

| Category | Changes |
|----------|---------|
| ESLint Fixes | ${results.eslintFixes} problems fixed |
| Prettier | ${results.prettierChanges} files formatted |
| Build Status | ${Object.keys(results.buildStats).length > 0 ? "‚úÖ Success" : "‚ö†Ô∏è Check logs"} |
| Build Size | ${getBuildSize()} |

`;

  // Script Results
  if (results.scriptResults.length > 0) {
    body += `### üîß Script Results

`;
    for (const result of results.scriptResults) {
      body += `- ${result}\n`;
    }
    body += "\n";
  }

  // CSP Findings
  if (results.cspFindings.length > 0) {
    body += `### üõ°Ô∏è CSP Findings

> **Note**: CSP violations found but NOT automatically fixed to maintain security.

`;
    for (const finding of results.cspFindings) {
      body += `- \`${finding}\`\n`;
    }
    body += "\n";
  }

  // Build Stats
  if (Object.keys(results.buildStats).length > 0) {
    body += `### üì¶ Build Statistics

| File | Size |
|------|------|
`;
    for (const [file, size] of Object.entries(results.buildStats)) {
      body += `| \`${file}\` | ${size} |\n`;
    }
    body += "\n";
  }

  // Errors
  if (results.errors.length > 0) {
    body += `### ‚ö†Ô∏è Issues Found

`;
    for (const error of results.errors) {
      body += `- \`${error}\`\n`;
    }
    body += "\n";
  }

  body += `### üöÄ Next Steps

- Review the changes in this PR
- Verify build output with: \`npm run preview\` (port 4173)
- Merge if all checks pass

---
*Generated by Autopilot Workflow*`;

  return body;
}

function main() {
  try {
    console.log("Parsing autopilot logs...");
    const results = parseAutopilotLog();

    console.log("Generating PR body...");
    const prBody = generatePRBody(results);

    console.log("Writing pr-body.md...");
    writeFileSync("pr-body.md", prBody, "utf-8");

    console.log("Autopilot summary generated successfully");
    console.log(`- ESLint fixes: ${results.eslintFixes}`);
    console.log(`- Prettier changes: ${results.prettierChanges}`);
    console.log(`- CSP findings: ${results.cspFindings.length}`);
    console.log(`- Errors: ${results.errors.length}`);
  } catch (error) {
    console.error("Error generating autopilot summary:", error.message);

    // Fallback summary
    const fallbackBody = `## ü§ñ Autopilot Maintenance Summary

*Automated maintenance run completed*

### ‚ö†Ô∏è Summary Generation Failed

An error occurred while generating the detailed summary: \`${error.message}\`

### üìã Basic Changes Applied

- ESLint auto-fixes
- Prettier formatting
- Local maintenance scripts
- Build verification

Please check the workflow logs for detailed information.

---
*Generated by Autopilot Workflow (fallback mode)*`;

    writeFileSync("pr-body.md", fallbackBody, "utf-8");
    process.exit(1);
  }
}

main();
